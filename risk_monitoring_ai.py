"""
AI Í∏∞Î∞ò Í∏ÄÎ°úÎ≤å Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú - Complete Enhanced Version
22Í∞úÍµ≠ Ïã§ÏãúÍ∞Ñ Îâ¥Ïä§ Î™®ÎãàÌÑ∞ÎßÅ with AI Î∂ÑÏÑù, Ïä§ÏºÄÏ§ÑÎßÅ, Ï∫êÏã±
"""

import os
import json
import smtplib
import logging
import hashlib
import pickle
import schedule
import sys
import re
import time
import argparse
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Set
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from dateutil import parser
from dateutil.relativedelta import relativedelta
from dataclasses import dataclass, asdict
from pathlib import Path
from dotenv import load_dotenv
import google.generativeai as genai

# .env ÌååÏùº Î°úÎìú
load_dotenv()

# Î°úÍ∑∏ ÏÑ§Ï†ï
def setup_logging(log_level='INFO'):
    """Setup logging configuration"""
    log_format = '%(asctime)s - %(levelname)s - %(message)s'
    
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(logging.Formatter(log_format))
    
    file_handler = logging.FileHandler(
        f'monitoring_{datetime.now().strftime("%Y%m%d")}.log', 
        encoding='utf-8'
    )
    file_handler.setFormatter(logging.Formatter(log_format))
    
    logger = logging.getLogger()
    logger.setLevel(getattr(logging, log_level))
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    return logger

logger = setup_logging(os.getenv('LOG_LEVEL', 'INFO'))

@dataclass
class NewsItem:
    """News item data class"""
    title: str
    date: str
    source: str
    snippet: str
    link: str
    country: str
    country_code: str
    country_ko: str = ""
    thumbnail: str = ""
    search_type: str = "news"
    collected_at: str = ""
    news_hash: str = ""  # Îâ¥Ïä§ Í≥†Ïú† Ìï¥Ïãú
    
    # AI analysis result fields
    risk_score: float = 0.0
    risk_level: str = ""
    risk_category: str = ""
    ai_summary_ko: str = ""
    ai_full_translation_ko: str = ""
    is_duplicate: bool = False
    duplicate_of: str = ""
    ai_analysis_timestamp: str = ""
    
    def __post_init__(self):
        """Îâ¥Ïä§ Ìï¥Ïãú ÏÉùÏÑ±"""
        if not self.news_hash:
            content = f"{self.title}{self.snippet}{self.source}"
            self.news_hash = hashlib.md5(content.encode()).hexdigest()

class NewsCache:
    """Îâ¥Ïä§ Ï∫êÏãú Í¥ÄÎ¶¨ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, cache_dir: str = "news_cache"):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(exist_ok=True)
        self.company_cache_file = self.cache_dir / "company_news_cache.pkl"
        self.daily_cache_file = self.cache_dir / "daily_news_cache.pkl"
        
    def load_company_cache(self) -> Set[str]:
        """ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§ Ï∫êÏãú Î°úÎìú"""
        if self.company_cache_file.exists():
            try:
                with open(self.company_cache_file, 'rb') as f:
                    return pickle.load(f)
            except:
                return set()
        return set()
    
    def save_company_cache(self, news_hashes: Set[str]):
        """ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§ Ï∫êÏãú Ï†ÄÏû•"""
        with open(self.company_cache_file, 'wb') as f:
            pickle.dump(news_hashes, f)
    
    def clear_daily_cache(self):
        """ÏùºÏùº Ï∫êÏãú Ï¥àÍ∏∞Ìôî"""
        if self.daily_cache_file.exists():
            self.daily_cache_file.unlink()

class GeminiAnalyzer:
    """Gemini AI Î∂ÑÏÑù ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, api_key: str):
        """Gemini API Ï¥àÍ∏∞Ìôî"""
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.0-flash')
        logger.info("‚úÖ Gemini 2.0 Flash Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        
        # Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í∏∞Ï§Ä
        self.risk_thresholds = {
            'HIGH': 70,     # 70Ï†ê Ïù¥ÏÉÅ
            'MEDIUM': 40,   # 40-69Ï†ê
            'LOW': 20       # 20-39Ï†ê
        }
    
    def remove_duplicates(self, news_list: List[NewsItem]) -> List[NewsItem]:
        """AI Í∏∞Î∞ò Ï§ëÎ≥µ Îâ¥Ïä§ Ï†úÍ±∞"""
        logger.info("üîç AI Í∏∞Î∞ò Ï§ëÎ≥µ Îâ¥Ïä§ Ï†úÍ±∞ ÏãúÏûë...")
        
        if not news_list:
            return []
        
        unique_news = []
        
        # Íµ≠Í∞ÄÎ≥ÑÎ°ú Í∑∏Î£πÌôî
        country_news = {}
        for news in news_list:
            country = news.country
            if country not in country_news:
                country_news[country] = []
            country_news[country].append(news)
        
        # Í∞Å Íµ≠Í∞ÄÎ≥ÑÎ°ú AI Ï§ëÎ≥µ Ï≤¥ÌÅ¨
        for country, items in country_news.items():
            if not items:
                continue
            
            # ÎÇ†ÏßúÏàú Ï†ïÎ†¨ (ÏµúÏã† Ïö∞ÏÑ†)
            items.sort(key=lambda x: x.date, reverse=True)
            
            # Ï≤´ Î≤àÏß∏ Îâ¥Ïä§Îäî Î¨¥Ï°∞Í±¥ Ìè¨Ìï®
            unique_news.append(items[0])
            
            # ÎÇòÎ®∏ÏßÄ Îâ¥Ïä§Îì§Ïóê ÎåÄÌï¥ Ï§ëÎ≥µ Ï≤¥ÌÅ¨
            for i in range(1, len(items)):
                candidate = items[i]
                
                # Ïù¥ÎØ∏ Ï∂îÍ∞ÄÎêú Îâ¥Ïä§Îì§Í≥º ÎπÑÍµê (Í∞ôÏùÄ Íµ≠Í∞Ä ÎÇ¥ÏóêÏÑúÎßå)
                is_duplicate = False
                duplicate_of = None
                
                # Î∞∞ÏπòÎ°ú ÎπÑÍµê (ÏµúÎåÄ 5Í∞úÏî©)
                country_unique = [n for n in unique_news if n.country == country]
                
                if country_unique:
                    # AIÎ°ú Ï§ëÎ≥µ ÌåêÎã®
                    is_duplicate, duplicate_of = self._check_duplicate_with_ai(
                        candidate, 
                        country_unique[-min(5, len(country_unique)):]  # ÏµúÍ∑º 5Í∞úÏôÄÎßå ÎπÑÍµê
                    )
                
                if not is_duplicate:
                    unique_news.append(candidate)
                else:
                    candidate.is_duplicate = True
                    candidate.duplicate_of = duplicate_of or ""
            
            # ÏßÑÌñâ ÏÉÅÌô© Î°úÍ∑∏
            logger.info(f"  - {country}: {len(items)}Í±¥ ‚Üí {len([n for n in unique_news if n.country == country])}Í±¥")
        
        logger.info(f"‚úÖ AI Ï§ëÎ≥µ Ï†úÍ±∞ ÏôÑÎ£å: {len(news_list)} ‚Üí {len(unique_news)}Í±¥")
        return unique_news
    
    def _check_duplicate_with_ai(self, candidate: NewsItem, existing_news: List[NewsItem]) -> Tuple[bool, Optional[str]]:
        """AIÎ•º ÏÇ¨Ïö©Ìïú Ï§ëÎ≥µ Ï≤¥ÌÅ¨"""
        try:
            prompt = f"""Determine if the candidate news article covers the same event as any of the existing news articles.

[CANDIDATE NEWS]
Title: {candidate.title}
Content: {candidate.snippet}
Date: {candidate.date}
Source: {candidate.source}

[EXISTING NEWS LIST]
"""
            for idx, news in enumerate(existing_news, 1):
                prompt += f"""
{idx}.
Title: {news.title}
Content: {news.snippet}
Date: {news.date}
Source: {news.source}
"""
            
            prompt += """

CRITERIA FOR JUDGMENT:
1. Do they cover the same incident/event?
2. Do the key details (location, time, casualty numbers, etc.) match?
3. Is this actually the same news, not just a similar topic?

RESPONSE FORMAT:
IsDuplicate: (Yes/No)
DuplicateNumber: (1-5, or 0 if not duplicate)

Please respond concisely."""
            
            response = self.model.generate_content(prompt)
            result = response.text.strip()
            
            # Parse response
            is_duplicate = False
            duplicate_idx = 0
            
            lines = result.split('\n')
            for line in lines:
                line_lower = line.lower()
                if 'isduplicate:' in line_lower and 'yes' in line_lower:
                    is_duplicate = True
                elif 'duplicatenumber:' in line_lower:
                    match = re.search(r'\d+', line)
                    if match:
                        duplicate_idx = int(match.group())
            
            if is_duplicate and 1 <= duplicate_idx <= len(existing_news):
                return True, existing_news[duplicate_idx - 1].link
            
            return False, None
            
        except Exception as e:
            logger.error(f"AI duplicate check error: {e}")
            return False, None
    
    def analyze_risk_batch(self, news_list: List[NewsItem], batch_size: int = 5) -> List[NewsItem]:
        """Î∞∞Ïπò Îã®ÏúÑÎ°ú Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù"""
        logger.info(f"ü§ñ AI Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù ÏãúÏûë ({len(news_list)}Í±¥)...")
        
        analyzed_news = []
        
        # Î∞∞Ïπò Ï≤òÎ¶¨
        for i in range(0, len(news_list), batch_size):
            batch = news_list[i:i+batch_size]
            
            # ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
            prompt = self._create_risk_analysis_prompt(batch)
            
            try:
                # Gemini API Ìò∏Ï∂ú
                response = self.model.generate_content(prompt)
                
                # ÏùëÎãµ ÌååÏã±
                results = self._parse_risk_response(response.text, batch)
                analyzed_news.extend(results)
                
                # API Ìò∏Ï∂ú Í∞ÑÍ≤©
                time.sleep(1)
                
                # ÏßÑÌñâÏÉÅÌô© Î°úÍ∑∏
                logger.info(f"  - Î∂ÑÏÑù ÏßÑÌñâ: {min(i+batch_size, len(news_list))}/{len(news_list)}")
                
            except Exception as e:
                logger.error(f"‚ùå AI Î∂ÑÏÑù Ïò§Î•ò: {e}")
                # Ïò§Î•ò Ïãú Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
                for news in batch:
                    news.risk_score = 0
                    news.risk_level = ""
                analyzed_news.extend(batch)
        
        # Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í∏∞Ï§ÄÏúºÎ°ú ÌïÑÌÑ∞ÎßÅ
        filtered_news = [n for n in analyzed_news if n.risk_score >= self.risk_thresholds['LOW']]
        
        logger.info(f"‚úÖ AI Î∂ÑÏÑù ÏôÑÎ£å: {len(filtered_news)}Í±¥Ïù¥ Î¶¨Ïä§ÌÅ¨ Í∏∞Ï§Ä Ï∂©Ï°±")
        return filtered_news
    
    def _create_risk_analysis_prompt(self, news_batch: List[NewsItem]) -> str:
        """Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±"""
        prompt = """You are a risk analysis expert for a global construction company.
Please analyze the following news articles and evaluate the risk score for each.

EVALUATION CRITERIA:
1. Business Impact (0-40 points)
   - Project disruption/delay possibility
   - Financial loss magnitude
   - Legal/regulatory risks
   
2. Reputation Impact (0-30 points)
   - Negative media coverage potential
   - Brand image damage level
   - Stakeholder trust impact
   
3. Employee Safety/Harm (0-30 points)
   - Employee life/safety threats
   - Work environment deterioration
   - Evacuation/withdrawal necessity

SPECIAL WEIGHTS:
- Direct mention of Samsung C&T or Samsung Construction: +20 points
- Accidents with 10+ fatalities: +30 points
- National-scale disasters/calamities: +25 points
- Large-scale protests/political instability: +20 points

If news source is Samsung or official Samsung channels: -50 points (minimum 0 points)

DATE RELEVANCE PENALTY:
- News older than 7 days: -30 points
- News older than 30 days: -50 points
- News older than 1 year: -80 points

For each news item, respond in the following format:
[News Number]
RiskScore: (0-100)
RiskCategory: (Natural Disaster/Political Unrest/Accident/Health Crisis/Economic Crisis/Other)
KeyRisk: (One sentence summary)

NEWS LIST:
"""
        
        for idx, news in enumerate(news_batch):
            prompt += f"\n[{idx+1}]\n"
            prompt += f"Title: {news.title}\n"
            prompt += f"Country: {news.country}\n"
            prompt += f"Source: {news.source}\n"
            prompt += f"Content: {news.snippet}\n"
            prompt += f"Date: {news.date}\n"
        
        return prompt
    
    def _parse_risk_response(self, response_text: str, news_batch: List[NewsItem]) -> List[NewsItem]:
        """AI ÏùëÎãµ ÌååÏã±"""
        results = []
        
        # ÏùëÎãµÏùÑ Îâ¥Ïä§Î≥ÑÎ°ú Î∂ÑÎ¶¨
        sections = response_text.split('[')
        
        for section in sections[1:]:  # Ï≤´ Î≤àÏß∏Îäî Îπà Î¨∏ÏûêÏó¥
            try:
                lines = section.strip().split('\n')
                
                # Îâ¥Ïä§ Î≤àÌò∏ Ï∂îÏ∂ú
                news_idx = int(lines[0].split(']')[0]) - 1
                if news_idx >= len(news_batch):
                    continue
                
                news = news_batch[news_idx]
                
                # Î¶¨Ïä§ÌÅ¨ Ï†ïÎ≥¥ ÌååÏã±
                for line in lines[1:]:
                    line_lower = line.lower()
                    if 'riskscore:' in line_lower:
                        score_match = re.findall(r'\d+', line)
                        if score_match:
                            score = float(score_match[0])
                            news.risk_score = score
                    elif 'riskcategory:' in line_lower:
                        parts = line.split(':', 1)
                        if len(parts) > 1:
                            category = parts[1].strip()
                            news.risk_category = category
                
                # Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï
                if news.risk_score >= self.risk_thresholds['HIGH']:
                    news.risk_level = 'HIGH'
                elif news.risk_score >= self.risk_thresholds['MEDIUM']:
                    news.risk_level = 'MEDIUM'
                elif news.risk_score >= self.risk_thresholds['LOW']:
                    news.risk_level = 'LOW'
                else:
                    news.risk_level = ''
                
                news.ai_analysis_timestamp = datetime.now().isoformat()
                results.append(news)
                
            except Exception as e:
                logger.error(f"ÌååÏã± Ïò§Î•ò: {e}")
                continue
        
        return results
    
    def summarize_and_translate(self, news_list: List[NewsItem]) -> List[NewsItem]:
        """Îâ¥Ïä§ ÏöîÏïΩ Î∞è ÌïúÍµ≠Ïñ¥ Î≤àÏó≠"""
        logger.info("üìù Îâ¥Ïä§ ÏöîÏïΩ Î∞è Î≤àÏó≠ ÏãúÏûë...")
        
        total_items = len([n for n in news_list if n.risk_level])
        processed = 0
        
        for news in news_list:
            if not news.risk_level:
                continue
            
            try:
                if news.risk_level == 'HIGH':
                    # HIGH: Ï†ÑÏ≤¥ Î≤àÏó≠ + ÏöîÏïΩ
                    prompt = f"""Please translate and summarize the following news into Korean.

Title: {news.title}
Content: {news.snippet}
Date: {news.date}
Country: {news.country}

Please respond in the following format:
[Summary]
(3-4 sentences summarizing key points in Korean)

[Full Translation]
(Complete translation of the content in natural Korean)"""
                    
                    response = self.model.generate_content(prompt)
                    result = response.text
                    
                    # Separate summary and translation
                    if '[Summary]' in result and '[Full Translation]' in result:
                        summary = result.split('[Summary]')[1].split('[Full Translation]')[0].strip()
                        translation = result.split('[Full Translation]')[1].strip()
                        news.ai_summary_ko = summary
                        news.ai_full_translation_ko = translation
                    
                else:
                    # MEDIUM/LOW: Summary only
                    prompt = f"""Please summarize the following news in 3-4 sentences in Korean.

Title: {news.title}
Content: {news.snippet}
Date: {news.date}
Country: {news.country}"""
                    
                    response = self.model.generate_content(prompt)
                    news.ai_summary_ko = response.text.strip()
                
                time.sleep(0.5)  # API Ìò∏Ï∂ú Í∞ÑÍ≤©
                
                processed += 1
                if processed % 10 == 0:
                    logger.info(f"  - Î≤àÏó≠ ÏßÑÌñâ: {processed}/{total_items}")
                
            except Exception as e:
                logger.error(f"Î≤àÏó≠/ÏöîÏïΩ Ïò§Î•ò: {e}")
                news.ai_summary_ko = "Translation failed"
        
        logger.info("‚úÖ ÏöîÏïΩ Î∞è Î≤àÏó≠ ÏôÑÎ£å")
        return news_list

class AIRiskMonitoringSystem:
    """AI Í∏∞Î∞ò Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú (Í∏∞Î≥∏)"""
    
    def __init__(self, config_path='monitoring_config.json'):
        """ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî"""
        logger.info("="*70)
        logger.info("ü§ñ AI Í∏∞Î∞ò Í∏ÄÎ°úÎ≤å Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî")
        logger.info("="*70)
        
        # API ÌÇ§ ÌôïÏù∏
        self.serpapi_key = os.getenv('SERPAPI_KEY')
        self.gemini_key = os.getenv('GEMINI_API_KEY')
        
        if not self.serpapi_key:
            logger.error("‚ùå SERPAPI_KEYÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
            sys.exit(1)
        
        if not self.gemini_key:
            logger.error("‚ùå GEMINI_API_KEYÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
            sys.exit(1)
        
        # SerpAPI Ï¥àÍ∏∞Ìôî
        try:
            from serpapi import GoogleSearch
            self.GoogleSearch = GoogleSearch
            logger.info("‚úÖ SerpAPI Ìå®ÌÇ§ÏßÄ Î°úÎìú ÏôÑÎ£å")
        except ImportError:
            logger.error("‚ùå serpapi Ìå®ÌÇ§ÏßÄÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
            sys.exit(1)
        
        # Gemini Î∂ÑÏÑùÍ∏∞ Ï¥àÍ∏∞Ìôî
        self.analyzer = GeminiAnalyzer(self.gemini_key)
        
        # ÏÑ§Ï†ï ÌååÏùº Î°úÎìú
        self.load_config(config_path)
        
        # Ïù¥Î©îÏùº ÏÑ§Ï†ï
        self.setup_email_config()
        
        # Initialize statistics
        self.stats = {
            'api_calls': 0,
            'news_collected': 0,
            'news_after_dedup': 0,
            'news_analyzed': 0,
            'high_risk': 0,
            'medium_risk': 0,
            'low_risk': 0,
            'errors': 0,
            'start_time': datetime.now()
        }
    
    def load_config(self, config_path):
        """ÏÑ§Ï†ï ÌååÏùº Î°úÎìú"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                self.config = json.load(f)
            
            self.countries = {
                k: v for k, v in self.config['countries'].items() 
                if v.get('active', True)
            }
            
            self.risk_keywords = self.config['search_keywords']['risk_keywords']
            self.combined_query = self.config['search_keywords']['combined_query']
            self.company_keywords = self.config['company_keywords']
            self.korean_media = self.config.get('korean_media', {})
            
            logger.info(f"‚úÖ ÏÑ§Ï†ï ÌååÏùº Î°úÎìú ÏôÑÎ£å: {config_path}")
            
        except Exception as e:
            logger.error(f"‚ùå ÏÑ§Ï†ï ÌååÏùº Î°úÎìú Ïã§Ìå®: {e}")
            sys.exit(1)
    
    def setup_email_config(self):
        """Ïù¥Î©îÏùº ÏÑ§Ï†ï"""
        self.email_config = {
            'smtp_server': os.getenv('SMTP_SERVER', 'smtp.gmail.com'),
            'smtp_port': int(os.getenv('SMTP_PORT', 587)),
            'sender_email': os.getenv('SENDER_EMAIL', ''),
            'sender_password': os.getenv('SENDER_PASSWORD', ''),
            'recipients': []
        }
        
        env_recipients = os.getenv('RECIPIENT_EMAILS', '')
        if env_recipients:
            self.email_config['recipients'] = [
                email.strip() for email in env_recipients.split(',')
            ]

    def parse_news_date(self, date_str: str) -> Optional[datetime]:
        """Parse various date formats from news"""
        if not date_str:
            return None
            
        try:
            # Remove timezone info and clean up
            date_str = date_str.strip()
            
            # Try dateutil parser first (handles many formats)
            parsed_date = parser.parse(date_str, fuzzy=True)
            return parsed_date
            
        except Exception as e:
            logger.debug(f"Date parsing failed for: {date_str} - {e}")
            
            # Try specific formats as fallback
            formats = [
                '%m/%d/%Y',
                '%Y-%m-%d',
                '%d/%m/%Y',
                '%B %d, %Y',
                '%b %d, %Y',
                '%Y/%m/%d',
            ]
            
            for fmt in formats:
                try:
                    return datetime.strptime(date_str.split(',')[0], fmt)
                except:
                    continue
            
            # If all parsing fails, return None
            return None
        
    def filter_recent_news(self, news_list: List[NewsItem], days: int = 7) -> List[NewsItem]:
        """Filter news to keep only recent items within specified days"""
        logger.info(f"üìÖ Starting date filtering (keeping last {days} days)...")
        
        # timezone-aware datetime ÏÉùÏÑ±
        from datetime import timezone
        cutoff_date = datetime.now(timezone.utc) - timedelta(days=days)
        filtered_news = []
        old_news_count = 0
        unparseable_dates = 0
        
        for news in news_list:
            # Parse the news date
            news_date = self.parse_news_date(news.date)
            
            if news_date is None:
                # ÎÇ†ÏßúÎ•º ÌååÏã±Ìï† Ïàò ÏóÜÏúºÎ©¥ Ìè¨Ìï®ÌïòÎêò Í≤ΩÍ≥† Î°úÍ∑∏
                unparseable_dates += 1
                logger.warning(f"Cannot parse date for: {news.title[:50]}... Date: {news.date}")
                filtered_news.append(news)
                continue
            
            # timezoneÏù¥ ÏóÜÎäî ÎÇ†ÏßúÏóê UTC timezone Ï∂îÍ∞Ä
            if news_date.tzinfo is None:
                news_date = news_date.replace(tzinfo=timezone.utc)
            
            # Îâ¥Ïä§Í∞Ä ÏµúÍ∑º Í≤ÉÏù∏ÏßÄ ÌôïÏù∏
            if news_date >= cutoff_date:
                filtered_news.append(news)
            else:
                old_news_count += 1
                # UTC Í∏∞Ï§ÄÏúºÎ°ú ÎÇ†Ïßú Ï∞®Ïù¥ Í≥ÑÏÇ∞
                current_time = datetime.now(timezone.utc)
                days_old = (current_time - news_date).days
                logger.debug(f"Filtered old news ({days_old} days old): {news.title[:50]}...")
        
        logger.info(f"‚úÖ Date filtering complete: {len(news_list)} ‚Üí {len(filtered_news)} items")
        logger.info(f"   - Removed {old_news_count} old news items")
        if unparseable_dates > 0:
            logger.warning(f"   - {unparseable_dates} items with unparseable dates (kept)")
        
        return filtered_news

    def search_news(self, query: str, country_code: str = None, 
                   country_name: str = None, search_type: str = 'news') -> List[NewsItem]:
        """Îâ¥Ïä§ Í≤ÄÏÉâ"""
        results = []
        
        try:
            if search_type == 'news':
                params = {
                    "api_key": self.serpapi_key,
                    "engine": "google_news",
                    "q": query,
                    "when": "7d"
                }
                
                if country_code:
                    params["gl"] = country_code
                    params["hl"] = "en"
            else:
                params = {
                    "api_key": self.serpapi_key,
                    "engine": "google",
                    "q": query,
                    "num": "10",
                    "tbs": "qdr:w"
                }
                
                if country_code:
                    params["gl"] = country_code
                    params["hl"] = "ko" if country_code == "kr" else "en"
            
            search = self.GoogleSearch(params)
            response = search.get_dict()
            
            self.stats['api_calls'] += 1
            
            # Í≤∞Í≥º ÌååÏã±
            if search_type == 'news' and "news_results" in response:
                for item in response["news_results"][:10]:
                    news_item = NewsItem(
                        title=item.get('title', ''),
                        date=item.get('date', ''),
                        source=item.get('source', {}).get('name', 'Unknown'),
                        snippet=item.get('snippet', ''),
                        link=item.get('link', ''),
                        country=country_name or 'Global',
                        country_code=country_code or 'global',
                        thumbnail=item.get('thumbnail', ''),
                        search_type=search_type,
                        collected_at=datetime.now().isoformat()
                    )
                    results.append(news_item)
                    
            elif search_type != 'news' and "organic_results" in response:
                for item in response["organic_results"][:5]:
                    news_item = NewsItem(
                        title=item.get('title', ''),
                        date=datetime.now().strftime('%Y-%m-%d'),
                        source=item.get('displayed_link', 'Unknown'),
                        snippet=item.get('snippet', ''),
                        link=item.get('link', ''),
                        country=country_name or 'Korea',
                        country_code=country_code or 'kr',
                        search_type=search_type,
                        collected_at=datetime.now().isoformat()
                    )
                    results.append(news_item)
            
            self.stats['news_collected'] += len(results)
            
        except Exception as e:
            logger.error(f"API Ïò§Î•ò: {e}")
            self.stats['errors'] += 1
        
        return results
    
    def collect_all_news(self) -> List[NewsItem]:
        """Î™®Îì† Îâ¥Ïä§ ÏàòÏßë"""
        all_news = []
        
        # 1. Íµ≠Í∞ÄÎ≥Ñ Îâ¥Ïä§
        logger.info("\nüåç Íµ≠Í∞ÄÎ≥Ñ Î¶¨Ïä§ÌÅ¨ Îâ¥Ïä§ ÏàòÏßë ÏãúÏûë")
        for idx, (country_code, country_info) in enumerate(self.countries.items(), 1):
            logger.info(f"[{idx}/{len(self.countries)}] {country_info['name_ko']} ({country_info['name']})")
            
            query = f"{country_info['name']} {self.combined_query}"
            news = self.search_news(
                query=query,
                country_code=country_info['gl'],
                country_name=country_info['name'],
                search_type='news'
            )
            
            for item in news:
                item.country_ko = country_info['name_ko']
            
            all_news.extend(news)
            time.sleep(1)
        
        # 2. ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§
        logger.info("\nüè¢ ÌöåÏÇ¨ ÌÇ§ÏõåÎìú Îâ¥Ïä§ ÏàòÏßë ÏãúÏûë")
        for idx, keyword in enumerate(self.company_keywords, 1):
            logger.info(f"[{idx}/{len(self.company_keywords)}] {keyword}")
            
            query = f'"{keyword}" construction project accident'
            news = self.search_news(query=query, search_type='news')
            all_news.extend(news)
            time.sleep(1)
        
        # 3. ÌïúÍµ≠ ÎØ∏ÎîîÏñ¥
        logger.info("\nüá∞üá∑ ÌïúÍµ≠ Ïñ∏Î°† Î™®ÎãàÌÑ∞ÎßÅ")
        for site in self.korean_media.get('sites', []):
            if not site.get('active', False):
                continue
            
            for term in self.korean_media.get('search_terms', []):
                query = f'{site["selector"]} "{term}"'
                news = self.search_news(
                    query=query,
                    country_code='kr',
                    country_name='Korea',
                    search_type='web'
                )
                all_news.extend(news)
                time.sleep(1)
        
        # 4. Ïò§ÎûòÎêú Îâ¥Ïä§ ÏÇ≠Ï†úÎ•º ÏúÑÌïú ÎÇ†Ïßú ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©
        logger.info(f"\nüìÖ ÎÇ†Ïßú ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö© Ï§ë...")
        logger.info(f"ÌïÑÌÑ∞ÎßÅ Ïù¥Ï†Ñ Ï†ÑÏ≤¥ Îâ¥Ïä§ Í∞ØÏàò : {len(all_news)}")
        
        # Filter to keep only recent news (default: last 7 days)
        days_to_keep = self.config.get('search_settings', {}).get('days_to_keep', 7)
        all_news = self.filter_recent_news(all_news, days=days_to_keep)
        
        logger.info(f"ÌïÑÌÑ∞ÎßÅ Ïù¥ÌõÑ Ï†ÑÏ≤¥ Îâ¥Ïä§ Í∞ØÏàò : {len(all_news)}")
        
        return all_news
    
    def create_ai_html_report(self, analyzed_news: List[NewsItem]) -> str:
        """AI Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ìè¨Ìï®Ìïú HTML Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±"""
        # Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®Î≥Ñ Î∂ÑÎ•ò
        high_risk = [n for n in analyzed_news if n.risk_level == 'HIGH']
        medium_risk = [n for n in analyzed_news if n.risk_level == 'MEDIUM']
        low_risk = [n for n in analyzed_news if n.risk_level == 'LOW']
        
        html = f"""<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Í∏ÄÎ°úÎ≤å Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ Î¶¨Ìè¨Ìä∏ - {datetime.now().strftime('%Y-%m-%d')}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }}
        .container {{
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }}
        .header h1 {{
            font-size: 36px;
            margin-bottom: 10px;
            font-weight: 700;
        }}
        .ai-badge {{
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin-top: 10px;
        }}
        .stats-container {{
            background: #f8f9fa;
            padding: 30px;
            border-bottom: 2px solid #e9ecef;
        }}
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }}
        .stat-card {{
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }}
        .content {{
            padding: 40px;
        }}
        .news-card {{
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }}
        .news-card.high-risk {{
            border-left: 5px solid #dc3545;
        }}
        .news-card.medium-risk {{
            border-left: 5px solid #ffc107;
        }}
        .news-card.low-risk {{
            border-left: 5px solid #28a745;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç Í∏ÄÎ°úÎ≤å Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ Î¶¨Ìè¨Ìä∏</h1>
            <div class="ai-badge">Powered by Gemini 2.0 Flash</div>
        </div>
        
        <div class="stats-container">
            <div class="stats-grid">
                <div class="stat-card">
                    <div style="font-size: 42px; font-weight: bold;">{len(analyzed_news)}</div>
                    <div>Total News</div>
                </div>
                <div class="stat-card">
                    <div style="font-size: 42px; font-weight: bold; color: #dc3545;">{len(high_risk)}</div>
                    <div>High Risk</div>
                </div>
                <div class="stat-card">
                    <div style="font-size: 42px; font-weight: bold; color: #ffc107;">{len(medium_risk)}</div>
                    <div>Medium Risk</div>
                </div>
                <div class="stat-card">
                    <div style="font-size: 42px; font-weight: bold; color: #28a745;">{len(low_risk)}</div>
                    <div>Low Risk</div>
                </div>
            </div>
        </div>
        
        <div class="content">
"""
        
        # HIGH RISK ÏÑπÏÖò
        if high_risk:
            html += "<h2>‚ö†Ô∏è HIGH RISK - Ï¶âÏãú ÌôïÏù∏ ÌïÑÏöî</h2>"
            for news in high_risk[:20]:
                html += self._create_ai_news_card(news, 'high')
        
        # MEDIUM RISK ÏÑπÏÖò
        if medium_risk:
            html += "<h2>üì¢ MEDIUM RISK - Ï£ºÏùò ÌïÑÏöî</h2>"
            for news in medium_risk[:15]:
                html += self._create_ai_news_card(news, 'medium')
        
        # LOW RISK ÏÑπÏÖò
        if low_risk:
            html += "<h2>‚ÑπÔ∏è LOW RISK - Î™®ÎãàÌÑ∞ÎßÅ</h2>"
            for news in low_risk[:10]:
                html += self._create_ai_news_card(news, 'low')
        
        html += """
        </div>
    </div>
</body>
</html>"""
        
        return html
    
    def _create_ai_news_card(self, news: NewsItem, risk_class: str) -> str:
        """Îâ¥Ïä§ Ïπ¥Îìú HTML ÏÉùÏÑ±"""
        import html
        
        return f"""
        <div class="news-card {risk_class}-risk">
            <h3>{html.escape(news.title)}</h3>
            <p>üìç {news.country_ko or news.country} | üì∞ {html.escape(news.source)} | üìÖ {news.date}</p>
            <p><strong>Î¶¨Ïä§ÌÅ¨ Ï†êÏàò:</strong> {news.risk_score:.0f} | <strong>Ïπ¥ÌÖåÍ≥†Î¶¨:</strong> {news.risk_category or 'Other'}</p>
            <p><strong>AI ÏöîÏïΩ:</strong> {html.escape(news.ai_summary_ko or 'No summary')}</p>
            <a href="{news.link}" target="_blank">ÏõêÎ¨∏ Î≥¥Í∏∞ ‚Üí</a>
        </div>
"""

    def send_email_report(self, html_content: str, news_list: List[NewsItem], use_email_version: bool = False) -> bool:
        """Ïù¥Î©îÏùºÎ°ú Î¶¨Ìè¨Ìä∏ Ï†ÑÏÜ°"""
        try:
            # Í≥†ÏúÑÌóò Îâ¥Ïä§ Í∞úÏàò
            high_risk_count = len([n for n in news_list if n.risk_level == 'HIGH'])
            
            # Ïù¥Î©îÏùº Ï†úÎ™©
            subject = f"[Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ] {datetime.now().strftime('%Y-%m-%d')} - "
            if high_risk_count > 0:
                subject += f"‚ö†Ô∏è HIGH RISK {high_risk_count}Í±¥ Î∞úÏÉù"
            else:
                subject += "Ï†ïÏÉÅ Î™®ÎãàÌÑ∞ÎßÅ ÏôÑÎ£å"
            
            # Ïù¥Î©îÏùº ÏÉùÏÑ±
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.email_config['sender_email']
            msg['To'] = ', '.join(self.email_config['recipients'])
            
            # HTML Î≥∏Î¨∏ Ï≤®Î∂Ä
            html_part = MIMEText(html_content, 'html', 'utf-8')
            msg.attach(html_part)
            
            # SMTP ÏÑúÎ≤Ñ Ïó∞Í≤∞ Î∞è Ï†ÑÏÜ°
            with smtplib.SMTP(self.email_config['smtp_server'], self.email_config['smtp_port']) as server:
                server.starttls()
                server.login(self.email_config['sender_email'], self.email_config['sender_password'])
                server.send_message(msg)
                
            logger.info(f"üìß Ïù¥Î©îÏùº Ï†ÑÏÜ° ÏÑ±Í≥µ: {', '.join(self.email_config['recipients'])}")
            return True
            
        except Exception as e:
            logger.error(f"Ïù¥Î©îÏùº Ï†ÑÏÜ° Ïã§Ìå®: {e}")
            return False

    def run(self):
        """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
        logger.info("\n" + "="*70)
        logger.info("üöÄ AI Í∏∞Î∞ò Í∏ÄÎ°úÎ≤å Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë")
        logger.info("="*70)
        
        try:
            # 1. Îâ¥Ïä§ ÏàòÏßë
            logger.info("\nüì° Îâ¥Ïä§ ÏàòÏßë Îã®Í≥Ñ")
            all_news = self.collect_all_news()
            logger.info(f"‚úÖ Ï¥ù {len(all_news)}Í±¥ ÏàòÏßë ÏôÑÎ£å")
            
            # 2. AI Í∏∞Î∞ò Ï§ëÎ≥µ Ï†úÍ±∞
            logger.info("\nüîç AI Ï§ëÎ≥µ Ï†úÍ±∞ Îã®Í≥Ñ")
            unique_news = self.analyzer.remove_duplicates(all_news)
            self.stats['news_after_dedup'] = len(unique_news)
            logger.info(f"‚úÖ Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ {len(unique_news)}Í±¥")
            
            # 3. AI Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù
            logger.info("\nü§ñ AI Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù Îã®Í≥Ñ")
            analyzed_news = self.analyzer.analyze_risk_batch(unique_news)
            self.stats['news_analyzed'] = len(analyzed_news)
            
            # 4. ÏöîÏïΩ Î∞è Î≤àÏó≠
            logger.info("\nüìù ÏöîÏïΩ Î∞è Î≤àÏó≠ Îã®Í≥Ñ")
            final_news = self.analyzer.summarize_and_translate(analyzed_news)
            
            # 5. ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            self.stats['high_risk'] = len([n for n in final_news if n.risk_level == 'HIGH'])
            self.stats['medium_risk'] = len([n for n in final_news if n.risk_level == 'MEDIUM'])
            self.stats['low_risk'] = len([n for n in final_news if n.risk_level == 'LOW'])
            
            # 6. Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
            logger.info("\nüìä Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Îã®Í≥Ñ")
            html_content = self.create_ai_html_report(final_news)
            
            # 7. ÌååÏùº Ï†ÄÏû•
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            html_file = f'ai_risk_report_{timestamp}.html'
            with open(html_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            # 8. Ïù¥Î©îÏùº Ï†ÑÏÜ°
            if self.email_config['sender_email'] and self.email_config['recipients']:
                logger.info("\nüìß Ïù¥Î©îÏùº Ï†ÑÏÜ° ÏãúÏûë...")
                email_sent = self.send_email_report(html_content, final_news)
                if email_sent:
                    logger.info("‚úÖ Ïù¥Î©îÏùº Ï†ÑÏÜ° ÏôÑÎ£å")
                else:
                    logger.error("‚ùå Ïù¥Î©îÏùº Ï†ÑÏÜ° Ïã§Ìå®")
            
            # 9. Í≤∞Í≥º Ï∂úÎ†•
            duration = datetime.now() - self.stats['start_time']
            logger.info("\n" + "="*70)
            logger.info("‚úÖ AI Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏôÑÎ£å!")
            logger.info(f"ÏÜåÏöî ÏãúÍ∞Ñ: {str(duration).split('.')[0]}")
            logger.info(f"ÏàòÏßë: {self.stats['news_collected']}Í±¥")
            logger.info(f"AI Î∂ÑÏÑù: {self.stats['news_analyzed']}Í±¥")
            logger.info(f"HIGH: {self.stats['high_risk']}Í±¥")
            logger.info(f"MEDIUM: {self.stats['medium_risk']}Í±¥")
            logger.info(f"LOW: {self.stats['low_risk']}Í±¥")
            logger.info(f"ÏÉùÏÑ± ÌååÏùº: {html_file}")
            logger.info("="*70)
            
            return {
                'success': True,
                'stats': self.stats,
                'files': {'html': html_file}
            }
            
        except Exception as e:
            logger.error(f"‚ùå Ïã§Ìñâ Ï§ë Ïò§Î•ò: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return {'success': False, 'error': str(e)}

class EnhancedAIRiskMonitoringSystem(AIRiskMonitoringSystem):
    """Í∞úÏÑ†Îêú AI Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú"""
    
    def __init__(self, config_path='monitoring_config.json', mode='normal'):
        """
        ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
        mode: 'normal' (Ï†ïÏÉÅ Ïã§Ìñâ), 'test' (ÌÖåÏä§Ìä∏ - 1Ìöå Ïã§Ìñâ), 'schedule' (Ïä§ÏºÄÏ§ÑÎßÅ)
        """
        super().__init__(config_path)
        self.mode = mode
        self.news_cache = NewsCache()
        self.company_news_hashes = self.news_cache.load_company_cache()
        
        logger.info(f"üöÄ ÏãúÏä§ÌÖú Î™®Îìú: {mode}")
        
    def collect_company_news(self) -> List[NewsItem]:
        """ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§Îßå ÏàòÏßë"""
        all_news = []
        
        # 1. ÌöåÏÇ¨ ÌÇ§ÏõåÎìú Îâ¥Ïä§
        logger.info("\nüè¢ ÌöåÏÇ¨ ÌÇ§ÏõåÎìú Îâ¥Ïä§ ÏàòÏßë ÏãúÏûë")
        for idx, keyword in enumerate(self.company_keywords, 1):
            logger.info(f"[{idx}/{len(self.company_keywords)}] {keyword}")
            
            query = f'"{keyword}" construction project accident'
            news = self.search_news(query=query, search_type='news')
            
            # Íµ≠Í∞ÄÎ•º "ÏÇºÏÑ±Î¨ºÏÇ∞"ÏúºÎ°ú ÏÑ§Ï†ï
            for item in news:
                item.country = "ÏÇºÏÑ±Î¨ºÏÇ∞"
                item.country_ko = "ÏÇºÏÑ±Î¨ºÏÇ∞"
                item.country_code = "samsung"
            
            all_news.extend(news)
            time.sleep(1)
        
        # 2. ÌïúÍµ≠ ÎØ∏ÎîîÏñ¥ÏóêÏÑú ÏÇºÏÑ±Î¨ºÏÇ∞ Í≤ÄÏÉâ
        logger.info("\nüá∞üá∑ ÌïúÍµ≠ Ïñ∏Î°† Î™®ÎãàÌÑ∞ÎßÅ")
        for site in self.korean_media.get('sites', []):
            if not site.get('active', False):
                continue
            
            for term in self.korean_media.get('search_terms', []):
                query = f'{site["selector"]} "{term}"'
                news = self.search_news(
                    query=query,
                    country_code='kr',
                    country_name='ÏÇºÏÑ±Î¨ºÏÇ∞',  # Korea ÎåÄÏã† ÏÇºÏÑ±Î¨ºÏÇ∞
                    search_type='web'
                )
                
                # Íµ≠Í∞ÄÎ•º "ÏÇºÏÑ±Î¨ºÏÇ∞"ÏúºÎ°ú ÏÑ§Ï†ï
                for item in news:
                    item.country = "ÏÇºÏÑ±Î¨ºÏÇ∞"
                    item.country_ko = "ÏÇºÏÑ±Î¨ºÏÇ∞"
                    item.country_code = "samsung"
                
                all_news.extend(news)
                time.sleep(1)
        
        return all_news
    
    def collect_country_news(self) -> List[NewsItem]:
        """Íµ≠Í∞ÄÎ≥Ñ Î¶¨Ïä§ÌÅ¨ Îâ¥Ïä§Îßå ÏàòÏßë"""
        all_news = []
        
        logger.info("\nüåç Íµ≠Í∞ÄÎ≥Ñ Î¶¨Ïä§ÌÅ¨ Îâ¥Ïä§ ÏàòÏßë ÏãúÏûë")
        for idx, (country_code, country_info) in enumerate(self.countries.items(), 1):
            logger.info(f"[{idx}/{len(self.countries)}] {country_info['name_ko']} ({country_info['name']})")
            
            query = f"{country_info['name']} {self.combined_query}"
            news = self.search_news(
                query=query,
                country_code=country_info['gl'],
                country_name=country_info['name'],
                search_type='news'
            )
            
            for item in news:
                item.country_ko = country_info['name_ko']
            
            all_news.extend(news)
            time.sleep(1)
        
        return all_news
    
    def filter_new_company_news(self, news_list: List[NewsItem]) -> List[NewsItem]:
        """ÏÉàÎ°úÏö¥ ÌöåÏÇ¨ Îâ¥Ïä§Îßå ÌïÑÌÑ∞ÎßÅ"""
        new_news = []
        new_hashes = set()
        
        for news in news_list:
            if news.news_hash not in self.company_news_hashes:
                new_news.append(news)
                new_hashes.add(news.news_hash)
                logger.info(f"üÜï ÏÉàÎ°úÏö¥ Îâ¥Ïä§ Î∞úÍ≤¨: {news.title[:50]}...")
        
        # Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
        if new_hashes:
            self.company_news_hashes.update(new_hashes)
            self.news_cache.save_company_cache(self.company_news_hashes)
            logger.info(f"‚úÖ {len(new_news)}Í±¥Ïùò ÏÉàÎ°úÏö¥ ÌöåÏÇ¨ Îâ¥Ïä§ Î∞úÍ≤¨")
        else:
            logger.info("‚ÑπÔ∏è ÏÉàÎ°úÏö¥ ÌöåÏÇ¨ Îâ¥Ïä§ ÏóÜÏùå")
        
        return new_news
    
    def create_email_compatible_html_report(self, analyzed_news: List[NewsItem]) -> str:
        """Ïù¥Î©îÏùº ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ìò∏Ìôò HTML Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±"""
        
        # Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®Î≥Ñ Î∂ÑÎ•ò
        high_risk = [n for n in analyzed_news if n.risk_level == 'HIGH']
        medium_risk = [n for n in analyzed_news if n.risk_level == 'MEDIUM']
        low_risk = [n for n in analyzed_news if n.risk_level == 'LOW']
        
        # Íµ≠Í∞ÄÎ≥Ñ Î¶¨Ïä§ÌÅ¨ ÏßëÍ≥Ñ
        country_risks = {}
        for news in analyzed_news:
            country = news.country_ko or news.country
            if country not in country_risks:
                country_risks[country] = {'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
            country_risks[country][news.risk_level] += 1
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ Î¶¨Ìè¨Ìä∏ - {datetime.now().strftime('%Y-%m-%d')}</title>
</head>
<body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f4f4f4;">
    
    <!-- Ï†ÑÏ≤¥ Ïª®ÌÖåÏù¥ÎÑà -->
    <table width="100%" cellpadding="0" cellspacing="0" border="0" style="background-color: #f4f4f4;">
        <tr>
            <td align="center" style="padding: 20px;">
                
                <!-- Î©îÏù∏ Ïª®ÌÖåÏù¥ÎÑà -->
                <table width="600" cellpadding="0" cellspacing="0" border="0" style="background-color: #ffffff; border-radius: 8px;">
                    
                    <!-- Ìó§Îçî -->
                    <tr>
                        <td style="background-color: #6b46c1; padding: 30px; text-align: center; border-radius: 8px 8px 0 0;">
                            <h1 style="color: #ffffff; margin: 0; font-size: 28px;">üåç G/OÏã§ Í∏ÄÎ°úÎ≤å Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ</h1>
                            <p style="color: #ffffff; margin: 10px 0 0 0; font-size: 14px;">
                                {datetime.now().strftime('%YÎÖÑ %mÏõî %dÏùº')} | Samsung C&T
                            </p>
                        </td>
                    </tr>
                    
                    <!-- ÌÜµÍ≥Ñ ÏöîÏïΩ -->
                    <tr>
                        <td style="padding: 30px;">
                            <table width="100%" cellpadding="0" cellspacing="0" border="0">
                                <tr>
                                    <td style="text-align: center; padding: 10px;">
                                        <div style="font-size: 36px; font-weight: bold; color: #6b46c1;">{len(analyzed_news)}</div>
                                        <div style="color: #666; font-size: 12px; margin-top: 5px;">Ï†ÑÏ≤¥ Îâ¥Ïä§</div>
                                    </td>
                                    <td style="text-align: center; padding: 10px;">
                                        <div style="font-size: 36px; font-weight: bold; color: #dc3545;">{len(high_risk)}</div>
                                        <div style="color: #666; font-size: 12px; margin-top: 5px;">HIGH RISK</div>
                                    </td>
                                    <td style="text-align: center; padding: 10px;">
                                        <div style="font-size: 36px; font-weight: bold; color: #ffc107;">{len(medium_risk)}</div>
                                        <div style="color: #666; font-size: 12px; margin-top: 5px;">MEDIUM RISK</div>
                                    </td>
                                    <td style="text-align: center; padding: 10px;">
                                        <div style="font-size: 36px; font-weight: bold; color: #28a745;">{len(low_risk)}</div>
                                        <div style="color: #666; font-size: 12px; margin-top: 5px;">LOW RISK</div>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                    
                    <!-- Íµ≠Í∞ÄÎ≥Ñ ÌòÑÌô© -->
                    <tr>
                        <td style="padding: 0 30px 30px;">
                            <h2 style="color: #333; font-size: 20px; margin-bottom: 15px;">üìä Íµ≠Í∞ÄÎ≥Ñ Î¶¨Ïä§ÌÅ¨ ÌòÑÌô©</h2>
                            <table width="100%" cellpadding="8" cellspacing="0" border="1" style="border-collapse: collapse; border-color: #ddd;">
                                <tr style="background-color: #f8f9fa;">
                                    <th style="text-align: left; color: #333;">Íµ≠Í∞Ä</th>
                                    <th style="text-align: center; color: #333;">HIGH</th>
                                    <th style="text-align: center; color: #333;">MEDIUM</th>
                                    <th style="text-align: center; color: #333;">LOW</th>
                                    <th style="text-align: center; color: #333;">Ï¥ùÍ≥Ñ</th>
                                </tr>"""
    
        # Íµ≠Í∞ÄÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
        for country, risks in sorted(country_risks.items(), 
                                    key=lambda x: (x[1]['HIGH'], x[1]['MEDIUM']), 
                                    reverse=True):
            total = risks['HIGH'] + risks['MEDIUM'] + risks['LOW']
            html += f"""
                                <tr>
                                    <td style="padding: 8px;"><strong>{country}</strong></td>
                                    <td style="text-align: center; padding: 8px;">
                                        {f'<span style="background-color: #dc3545; color: white; padding: 2px 8px; border-radius: 3px;">{risks["HIGH"]}</span>' if risks['HIGH'] > 0 else '-'}
                                    </td>
                                    <td style="text-align: center; padding: 8px;">
                                        {f'<span style="background-color: #ffc107; color: #333; padding: 2px 8px; border-radius: 3px;">{risks["MEDIUM"]}</span>' if risks['MEDIUM'] > 0 else '-'}
                                    </td>
                                    <td style="text-align: center; padding: 8px;">
                                        {f'<span style="background-color: #28a745; color: white; padding: 2px 8px; border-radius: 3px;">{risks["LOW"]}</span>' if risks['LOW'] > 0 else '-'}
                                    </td>
                                    <td style="text-align: center; padding: 8px;"><strong>{total}</strong></td>
                                </tr>"""
        
        html += """
                            </table>
                        </td>
                    </tr>"""
        
        # HIGH RISK Îâ¥Ïä§
        if high_risk:
            html += """
                    <tr>
                        <td style="padding: 0 30px 30px;">
                            <h2 style="color: #dc3545; font-size: 20px; margin-bottom: 15px;">‚ö†Ô∏è HIGH RISK - Ï¶âÏãú ÌôïÏù∏ ÌïÑÏöî</h2>"""
            
            for news in high_risk[:5]:
                html += self._create_email_news_item(news, '#dc3545')
            
            html += """
                        </td>
                    </tr>"""
        
        # MEDIUM RISK Îâ¥Ïä§
        if medium_risk:
            html += """
                    <tr>
                        <td style="padding: 0 30px 30px;">
                            <h2 style="color: #ffc107; font-size: 20px; margin-bottom: 15px;">üì¢ MEDIUM RISK - Ï£ºÏùò ÌïÑÏöî</h2>"""
            
            for news in medium_risk[:5]:
                html += self._create_email_news_item(news, '#ffc107')
            
            html += """
                        </td>
                    </tr>"""
        
        # LOW RISK Îâ¥Ïä§
        if low_risk:
            html += """
                    <tr>
                        <td style="padding: 0 30px 30px;">
                            <h2 style="color: #28a745; font-size: 20px; margin-bottom: 15px;">‚ÑπÔ∏è LOW RISK - Î™®ÎãàÌÑ∞ÎßÅ</h2>"""
            
            for news in low_risk[:5]:
                html += self._create_email_news_item(news, '#28a745')
            
            html += """
                        </td>
                    </tr>"""
        
        # Ìë∏ÌÑ∞
        html += """
                    <tr>
                        <td style="background-color: #f8f9fa; padding: 20px; text-align: center; border-radius: 0 0 8px 8px;">
                            <p style="color: #666; margin: 0; font-size: 12px;">
                                Samsung C&T Global Risk Monitoring System<br>
                                Powered by SerpAPI & Gemini AI<br>
                                Generated at """ + datetime.now().strftime('%Y-%m-%d %H:%M:%S') + """
                            </p>
                        </td>
                    </tr>
                    
                </table>
                
            </td>
        </tr>
    </table>
    
</body>
</html>"""
        
        return html
    
    def _create_email_news_item(self, news: NewsItem, color: str) -> str:
        """Ïù¥Î©îÏùºÏö© Îâ¥Ïä§ ÏïÑÏù¥ÌÖú ÏÉùÏÑ±"""
        import html
        
        return f"""
        <table width="100%" cellpadding="0" cellspacing="0" border="0" style="margin-bottom: 20px; border-left: 4px solid {color}; background-color: #f9f9f9;">
            <tr>
                <td style="padding: 15px;">
                    <h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">
                        {html.escape(news.title[:100])}...
                    </h3>
                    <table cellpadding="0" cellspacing="0" border="0">
                        <tr>
                            <td style="padding-right: 15px; color: #666; font-size: 12px;">
                                üìç {news.country_ko or news.country}
                            </td>
                            <td style="padding-right: 15px; color: #666; font-size: 12px;">
                                üì∞ {html.escape(news.source)}
                            </td>
                            <td style="color: #666; font-size: 12px;">
                                üìÖ {news.date[:10] if len(news.date) > 10 else news.date}
                            </td>
                        </tr>
                    </table>
                    <div style="margin: 10px 0; padding: 10px; background-color: #fff; border-radius: 4px;">
                        <strong style="color: #666; font-size: 12px;">Î¶¨Ïä§ÌÅ¨ Ï†êÏàò:</strong> 
                        <span style="color: {color}; font-weight: bold;">{news.risk_score:.0f}Ï†ê</span> | 
                        <strong style="color: #666; font-size: 12px;">Ïπ¥ÌÖåÍ≥†Î¶¨:</strong> {news.risk_category or 'Other'}
                    </div>
                    <div style="margin: 10px 0; padding: 10px; background-color: #fffbf0; border-radius: 4px;">
                        <strong style="color: #666; font-size: 12px;">AI ÏöîÏïΩ:</strong><br>
                        <p style="margin: 5px 0 0 0; color: #333; font-size: 13px; line-height: 1.5;">
                            {html.escape(news.ai_summary_ko[:200] if news.ai_summary_ko else 'No summary available')}...
                        </p>
                    </div>
                    <a href="{news.link}" style="display: inline-block; margin-top: 10px; padding: 8px 15px; background-color: {color}; color: white; text-decoration: none; border-radius: 4px; font-size: 12px;">
                        ÏõêÎ¨∏ Î≥¥Í∏∞ ‚Üí
                    </a>
                </td>
            </tr>
        </table>"""
    
    def run_daily_monitoring(self):
        """ÏùºÏùº Ï†ÑÏ≤¥ Î™®ÎãàÌÑ∞ÎßÅ (ÏïÑÏπ® 7Ïãú)"""
        logger.info("\n" + "="*70)
        logger.info("üåÖ ÏùºÏùº Ï†ÑÏ≤¥ Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë")
        logger.info("="*70)
        
        try:
            # ÏùºÏùº Ï∫êÏãú Ï¥àÍ∏∞Ìôî
            self.news_cache.clear_daily_cache()
            
            # 1. Íµ≠Í∞ÄÎ≥Ñ Îâ¥Ïä§ ÏàòÏßë
            country_news = self.collect_country_news()
            
            # 2. ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§ ÏàòÏßë
            company_news = self.collect_company_news()
            
            # 3. ÌÜµÌï©
            all_news = country_news + company_news
            logger.info(f"‚úÖ Ï¥ù {len(all_news)}Í±¥ ÏàòÏßë ÏôÑÎ£å")
            
            # 4. ÎÇ†Ïßú ÌïÑÌÑ∞ÎßÅ
            days_to_keep = self.config.get('search_settings', {}).get('days_to_keep', 7)
            all_news = self.filter_recent_news(all_news, days=days_to_keep)
            
            # 5. AI Î∂ÑÏÑù ÏßÑÌñâ
            unique_news = self.analyzer.remove_duplicates(all_news)
            analyzed_news = self.analyzer.analyze_risk_batch(unique_news)
            final_news = self.analyzer.summarize_and_translate(analyzed_news)
            
            # 6. Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Î∞è Ï†ÑÏÜ°
            html_content = self.create_ai_html_report(final_news)
            email_html = self.create_email_compatible_html_report(final_news)
            
            # ÌååÏùº Ï†ÄÏû•
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            html_file = f'daily_risk_report_{timestamp}.html'
            with open(html_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            # Ïù¥Î©îÏùº Ï†ÑÏÜ°
            if self.email_config['sender_email'] and self.email_config['recipients']:
                self.send_email_report(email_html, final_news, use_email_version=True)
            
            logger.info("‚úÖ ÏùºÏùº Î™®ÎãàÌÑ∞ÎßÅ ÏôÑÎ£å")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå ÏùºÏùº Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}")
            return False
    
    def run_company_monitoring(self):
        """ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§Îßå Î™®ÎãàÌÑ∞ÎßÅ (3ÏãúÍ∞ÑÎßàÎã§)"""
        logger.info("\n" + "="*70)
        logger.info("üè¢ ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë")
        logger.info("="*70)
        
        try:
            # 1. ÌöåÏÇ¨ Îâ¥Ïä§Îßå ÏàòÏßë
            company_news = self.collect_company_news()
            
            # 2. ÎÇ†Ïßú ÌïÑÌÑ∞ÎßÅ
            company_news = self.filter_recent_news(company_news, days=1)  # ÏµúÍ∑º 1Ïùº
            
            # 3. ÏÉàÎ°úÏö¥ Îâ¥Ïä§Îßå ÌïÑÌÑ∞ÎßÅ
            new_news = self.filter_new_company_news(company_news)
            
            if not new_news:
                logger.info("‚ÑπÔ∏è ÏÉàÎ°úÏö¥ ÌöåÏÇ¨ Í¥ÄÎ†® Îâ¥Ïä§ ÏóÜÏùå")
                return True
            
            # 4. AI Î∂ÑÏÑù
            logger.info(f"ü§ñ {len(new_news)}Í±¥Ïùò ÏÉàÎ°úÏö¥ Îâ¥Ïä§ Î∂ÑÏÑù ÏãúÏûë")
            unique_news = self.analyzer.remove_duplicates(new_news)
            analyzed_news = self.analyzer.analyze_risk_batch(unique_news)
            
            # Î¶¨Ïä§ÌÅ¨Í∞Ä ÏûàÎäî Îâ¥Ïä§Îßå ÌïÑÌÑ∞ÎßÅ
            risk_news = [n for n in analyzed_news if n.risk_level in ['HIGH', 'MEDIUM']]
            
            if risk_news:
                # ÏöîÏïΩ Î∞è Î≤àÏó≠
                final_news = self.analyzer.summarize_and_translate(risk_news)
                
                # Í∏¥Í∏â ÏïåÎ¶º Ïù¥Î©îÏùº ÏÉùÏÑ±
                email_html = self.create_urgent_email_report(final_news)
                
                # Ïù¥Î©îÏùº Ï†ÑÏÜ°
                if self.email_config['sender_email'] and self.email_config['recipients']:
                    subject = f"[Í∏¥Í∏â] ÏÇºÏÑ±Î¨ºÏÇ∞ Í¥ÄÎ†® Î¶¨Ïä§ÌÅ¨ Î∞úÍ≤¨ - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
                    self.send_urgent_email(email_html, subject)
                
                logger.info(f"‚ö†Ô∏è {len(risk_news)}Í±¥Ïùò Î¶¨Ïä§ÌÅ¨ Îâ¥Ïä§ Î∞úÍ≤¨ Î∞è ÏïåÎ¶º Ï†ÑÏÜ°")
            else:
                logger.info("‚úÖ Î¶¨Ïä§ÌÅ¨ ÏàòÏ§ÄÏù¥ ÎÇÆÏùÄ Îâ¥Ïä§Îßå Î∞úÍ≤¨Îê®")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå ÌöåÏÇ¨ Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}")
            return False
    
    def create_urgent_email_report(self, news_list: List[NewsItem]) -> str:
        """Í∏¥Í∏â ÏïåÎ¶ºÏö© Í∞ÑÎã®Ìïú Ïù¥Î©îÏùº HTML ÏÉùÏÑ±"""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ÏÇºÏÑ±Î¨ºÏÇ∞ Í¥ÄÎ†® Í∏¥Í∏â Î¶¨Ïä§ÌÅ¨ ÏïåÎ¶º</title>
</head>
<body style="margin: 0; padding: 20px; font-family: Arial, sans-serif; background-color: #f4f4f4;">
    <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff; border-radius: 8px; overflow: hidden;">
        <div style="background-color: #dc3545; padding: 20px; text-align: center;">
            <h1 style="color: #ffffff; margin: 0; font-size: 24px;">‚ö†Ô∏è ÏÇºÏÑ±Î¨ºÏÇ∞ Í¥ÄÎ†® Î¶¨Ïä§ÌÅ¨ Í∞êÏßÄ</h1>
            <p style="color: #ffffff; margin: 10px 0 0 0; font-size: 14px;">
                {datetime.now().strftime('%YÎÖÑ %mÏõî %dÏùº %H:%M')} ÏàòÏßë
            </p>
        </div>
        
        <div style="padding: 20px;">
            <p style="color: #333; margin-bottom: 20px;">
                ÏÇºÏÑ±Î¨ºÏÇ∞ Í¥ÄÎ†® ÏÉàÎ°úÏö¥ Î¶¨Ïä§ÌÅ¨ Îâ¥Ïä§ {len(news_list)}Í±¥Ïù¥ Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§.
            </p>"""
        
        for news in news_list:
            color = '#dc3545' if news.risk_level == 'HIGH' else '#ffc107'
            html += f"""
            <div style="border-left: 4px solid {color}; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9;">
                <h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">
                    {news.title[:100]}...
                </h3>
                <p style="margin: 5px 0; color: #666; font-size: 12px;">
                    üì∞ {news.source} | üìÖ {news.date[:10] if len(news.date) > 10 else news.date}
                </p>
                <p style="margin: 5px 0; color: {color}; font-weight: bold; font-size: 14px;">
                    Î¶¨Ïä§ÌÅ¨: {news.risk_level} ({news.risk_score:.0f}Ï†ê)
                </p>
                <p style="margin: 10px 0; color: #333; font-size: 13px;">
                    {news.ai_summary_ko[:150] if news.ai_summary_ko else 'No summary'}...
                </p>
                <a href="{news.link}" style="color: #007bff; text-decoration: none; font-size: 12px;">
                    ÏõêÎ¨∏ Î≥¥Í∏∞ ‚Üí
                </a>
            </div>"""
        
        html += """
        </div>
    </div>
</body>
</html>"""
        return html
    
    def send_urgent_email(self, html_content: str, subject: str) -> bool:
        """Í∏¥Í∏â Ïù¥Î©îÏùº Ï†ÑÏÜ°"""
        try:
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.email_config['sender_email']
            msg['To'] = ', '.join(self.email_config['recipients'])
            
            html_part = MIMEText(html_content, 'html', 'utf-8')
            msg.attach(html_part)
            
            with smtplib.SMTP(self.email_config['smtp_server'], self.email_config['smtp_port']) as server:
                server.starttls()
                server.login(self.email_config['sender_email'], self.email_config['sender_password'])
                server.send_message(msg)
                
            logger.info(f"üìß Í∏¥Í∏â Ïù¥Î©îÏùº Ï†ÑÏÜ° ÏÑ±Í≥µ")
            return True
            
        except Exception as e:
            logger.error(f"Ïù¥Î©îÏùº Ï†ÑÏÜ° Ïã§Ìå®: {e}")
            return False
    
    def run(self):
        """ÌÖåÏä§Ìä∏Ïö© Í∏∞Î≥∏ Ïã§Ìñâ Î©îÏÑúÎìú (Î∂ÄÎ™® ÌÅ¥ÎûòÏä§ Ïò§Î≤ÑÎùºÏù¥Îìú)"""
        logger.info("\n" + "="*70)
        logger.info("üß™ ÌÖåÏä§Ìä∏ Î™®Îìú Ïã§Ìñâ")
        logger.info("="*70)
        
        # Ï†ÑÏ≤¥ Î™®ÎãàÌÑ∞ÎßÅ Ïã§Ìñâ (ÏùºÏùº Î™®ÎãàÌÑ∞ÎßÅÍ≥º ÎèôÏùº)
        return self.run_daily_monitoring()
    
    def start_scheduler(self):
        """Ïä§ÏºÄÏ§ÑÎü¨ ÏãúÏûë"""
        logger.info("‚è∞ Ïä§ÏºÄÏ§ÑÎü¨ ÏãúÏûë")
        
        # Îß§Ïùº ÏïÑÏπ® 7Ïãú Ï†ÑÏ≤¥ Î™®ÎãàÌÑ∞ÎßÅ
        schedule.every().day.at("07:00").do(self.run_daily_monitoring)
        
        # 3ÏãúÍ∞ÑÎßàÎã§ ÌöåÏÇ¨ Î™®ÎãàÌÑ∞ÎßÅ
        schedule.every(3).hours.do(self.run_company_monitoring)
        
        logger.info("üìÖ Ïä§ÏºÄÏ§Ñ ÏÑ§Ï†ï ÏôÑÎ£å:")
        logger.info("  - ÏùºÏùº Ï†ÑÏ≤¥ Î™®ÎãàÌÑ∞ÎßÅ: Îß§Ïùº 07:00")
        logger.info("  - ÌöåÏÇ¨ Í¥ÄÎ†® Î™®ÎãàÌÑ∞ÎßÅ: 3ÏãúÍ∞ÑÎßàÎã§")
        
        # Ïä§ÏºÄÏ§ÑÎü¨ Ïã§Ìñâ
        while True:
            schedule.run_pending()
            time.sleep(60)  # 1Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨


def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    parser = argparse.ArgumentParser(description='AI Í∏∞Î∞ò Í∏ÄÎ°úÎ≤å Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ')
    parser.add_argument('--mode', choices=['normal', 'test', 'schedule', 'company'], 
                       default='test',
                       help='Ïã§Ìñâ Î™®Îìú: normal(ÏùºÎ∞ò), test(ÌÖåÏä§Ìä∏), schedule(Ïä§ÏºÄÏ§ÑÎßÅ), company(ÌöåÏÇ¨Îßå)')
    parser.add_argument('--config', default='monitoring_config.json', 
                       help='ÏÑ§Ï†ï ÌååÏùº Í≤ΩÎ°ú')
    args = parser.parse_args()
    
    try:
        monitor = EnhancedAIRiskMonitoringSystem(args.config, mode=args.mode)
        
        if args.mode == 'test':
            # ÌÖåÏä§Ìä∏ Î™®Îìú: 1Ìöå Ïã§Ìñâ
            logger.info("üß™ ÌÖåÏä§Ìä∏ Î™®Îìú - 1Ìöå Ïã§Ìñâ")
            monitor.run()
            
        elif args.mode == 'normal':
            # ÏùºÎ∞ò Î™®Îìú: ÏùºÏùº Ï†ÑÏ≤¥ Î™®ÎãàÌÑ∞ÎßÅ 1Ìöå Ïã§Ìñâ
            logger.info("üìä ÏùºÎ∞ò Î™®Îìú - Ï†ÑÏ≤¥ Î™®ÎãàÌÑ∞ÎßÅ Ïã§Ìñâ")
            monitor.run_daily_monitoring()
            
        elif args.mode == 'company':
            # ÌöåÏÇ¨ Î™®Îìú: ÌöåÏÇ¨ Í¥ÄÎ†®Îßå 1Ìöå Ïã§Ìñâ
            logger.info("üè¢ ÌöåÏÇ¨ Î™®Îìú - ÌöåÏÇ¨ Í¥ÄÎ†® Î™®ÎãàÌÑ∞ÎßÅ Ïã§Ìñâ")
            monitor.run_company_monitoring()
            
        elif args.mode == 'schedule':
            # Ïä§ÏºÄÏ§Ñ Î™®Îìú: ÏßÄÏÜçÏ†Å Ïã§Ìñâ
            logger.info("‚è∞ Ïä§ÏºÄÏ§Ñ Î™®Îìú - ÏûêÎèô Ïä§ÏºÄÏ§ÑÎßÅ ÏãúÏûë")
            monitor.start_scheduler()
            
    except KeyboardInterrupt:
        logger.info("\nÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§")
    except Exception as e:
        logger.error(f"ÏπòÎ™ÖÏ†Å Ïò§Î•ò: {e}")
        import traceback
        logger.error(traceback.format_exc())


if __name__ == "__main__":
    main()
            